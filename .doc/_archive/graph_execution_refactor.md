# 计算图执行机制重构方案

**[注：2025-07-23] 经过评估，当前项目重心为完善上层 API（如 Optimizer、DataLoader）和丰富功能示例，此底层重构方案暂时搁置。**

## 1. 背景与动机

当前计算图的执行（前向与反向传播）严重依赖`forward_pass_id`和`backward_pass_id`。这种机制通过为每次传播分配一个唯一的、递增的 ID，并将其标记在已计算的节点上，来避免重复计算。（注：`forward_pass_id`和`backward_pass_id`在`Graph`结构体中，用于记录上一次前向/反向传播的 ID，以便于在下一次传播时进行检查，避免重复计算。）

虽然此方法简单直观，但存在以下核心问题：

- **效率低下**：即使计算图中只有一小部分输入发生改变，`pass_id`机制也需要遍历整个计算图，对每个节点进行 ID 检查。大部分节点的计算虽然能通过 ID 匹配命中缓存，但遍历和检查本身的开销是巨大的，尤其是在图规模变大时。
- **可扩展性差**：像“部分前向传播”（只计算图的一个子集）或`detach`（在反向传播中剪掉某个分支）这样的高级功能，在`pass_id`模型下难以优雅地实现。逻辑会变得复杂且容易出错。
- **耦合度高**：计算的“时机”控制逻辑（`pass_id`检查）与节点的“计算”逻辑本身耦合在了一起，违反了关注点分离原则，使得代码更难维护和扩展。

为了构建一个更现代化、高效且灵活的计算图框架，我们提议移除`pass_id`机制，转向一个基于“反应式更新”和“外部调度”的新架构。

## 2. 核心设计思想

新架构的核心思想是：**从指令式遍览转变为反应式更新**，并通过**版本控制**和**拓扑排序**来实现高效的缓存利用。

- **反应式更新**：节点的计算不再由外部的`pass_id`强制驱动，而是由其上游输入节点的状态变化来“触发”。如果一个节点的**所有相关输入**都没有变化，它就不需要重新计算。
- **外部调度**：计算的顺序不再由节点间的递归调用决定，而是由一个中心的`Graph`执行器通过对图进行**拓扑排序**来统一调度。

## 3. 具体实现方案

### 3.1. 前向传播：基于版本号的“脏检查”机制

为了实现高效的反应式更新，我们将为每个节点引入一套版本控制状态，以替代全局的`pass_id`。

#### 3.1.1. 节点的核心状态

每个节点将维护以下三个核心状态：

1.  **`value`**: 节点的缓存值（`Option<Tensor>`）---可能是经由父节点计算的（如 Add 节点），也可能是直接被赋值的（如：Input 和 Parameter 节点）。初始时为`None`。
2.  **`value_version`**: 一个 u64 整数，代表节点`value`的版本。它**只在**节点成功完成一次重新计算后递增，初始时为 0（表示未计算或未设置值）。
3.  **`parents_values_versions`**: 一个字典（或类似结构），精确记录了【上一次计算本节点时，所使用的每一个父节点的`value_version`】。初始时为空字典，表示从未计算过。

#### 3.1.2. 核心流程：递归的“请求-返回”模型

整个过程由一次深度优先的递归调用完成，该调用包含两个阶段：

**阶段一：请求下溯 (Request Downstream / 刨根溯源)**

- 当外部调用 `graph.forward_node(Y)` 时，一个“对值的请求”被创建。
- 这个请求会以深度优先的方式，从 `Y` 递归地传递给它的父节点，再到父节点的父节点，一路“下溯”直到所有相关的祖先节点都被访问。
- 这个下溯过程的**唯一目的**是确保在任何节点开始决策之前，它所依赖的所有上游节点都已经被请求过。

**阶段二：决策与值返回 (Decide and Return Upstream)**

- 当递归的请求到达一个**叶子节点**（如 Input 或 Parameter），或者一个已经完成了对其所有父节点的请求的中间节点时，该节点的返回阶段开始。
- 一个节点 `N` **只有在收到了其所有父节点的返回值之后**，才能开始自己的决策和返回流程。
- **本地决策**：节点 `N` 会比较它收到的父节点们的当前 `value_version` 和自己 `parents_values_versions` 中记录的旧版本。
  - 如果**全部匹配**，节点 `N` 判定自己是“干净的”。
  - 如果**任何一个不匹配**，节点 `N` 判定自己是“脏的”。
- **向上返回值**：
  - 如果 `N` 是“干净的”，它**直接将其缓存的 `value`** 和未改变的 `value_version` 返回给调用它的子节点。
  - 如果 `N` 是“脏的”，它会先**执行计算**，更新自己的状态（`value`, `value_version`, `parents_values_versions`），然后**将新计算出的 `value`** 和新的 `value_version` 返回给调用它的子节点。

这个“请求下溯，值返回”的过程确保了在任何节点做决策或计算之前，它所依赖的所有上游信息都已准备就绪，从而以一种优雅的方式实现了拓扑排序和高效缓存。

#### 3.1.3. 循环依赖检测

在递归的"请求下溯"过程中，需要检测并防止计算图中的循环依赖。正常的深度学习计算图应该是**有向无环图(DAG)**，但在实现过程中可能会因为代码 bug 或用户错误而意外创建循环依赖。

**检测机制**：

- 在递归调用栈中维护一个访问集合，记录当前正在处理的节点
- 当开始处理一个节点时，检查它是否已在访问集合中
- 如果发现重复访问，说明存在循环依赖，应立即抛出错误而不是继续递归

**示例循环依赖**：

```
A → B → C → A  (错误的图结构)
```

当`graph.forward_node(A)`被调用时，会形成 A 请求 B，B 请求 C，C 请求 A 的无限递归。

注意：这与 RNN 中的时间循环不同。RNN 的循环是在时间维度上的（如`h_t`依赖`h_{t-1}`），每个时间步都是独立的 DAG，不会产生同一计算图内的循环依赖。

#### 3.1.4. 示例：`y = wx + b` 的执行过程

为了更清晰地理解，我们以 `y = wx + b` 为例。该表达式在图中被分解为：

- `Mul_Node = w * x`
- `Add_Node(y) = Mul_Node + b`

**场景：只有输入 `x` 的值发生了改变。**

1.  **请求 `y`**: `graph.forward_node(y)` 被调用，即向 `Add_Node` 请求其值。

2.  **`Add_Node` 的请求**: `Add_Node` 向其父节点 `Mul_Node` 和 `b` 发出请求。

    - **请求 `b`**: `b` 是一个参数节点，它的值没有变。它检查自己（没有父节点），发现自己是“干净的”，于是直接从缓存返回值和它的`value_version`。
    - **请求 `Mul_Node`**: `Add_Node` 向 `Mul_Node` 请求其值。

3.  **`Mul_Node` 的请求**: `Mul_Node` 为了响应请求，向其父节点 `w` 和 `x` 发出请求。

    - **请求 `w`**: `w` 是参数，值没变，直接返回缓存值和版本号。
    - **请求 `x`**: `x` 是输入，其值被改变了，`value_version` 已递增。`x` 返回新值和新版本号。

4.  **`Mul_Node` 的决策与计算**:

    - `Mul_Node` 收到了 `w` 和 `x` 的响应。它进行本地检查，发现 `w` 的版本号匹配，但 `x` 的版本号**不匹配**。
    - `Mul_Node` 判定自己是“脏的”，必须重新计算。
    - 它使用从 `w`（缓存）和 `x`（新值）获取的值，执行乘法运算。
    - 计算完成后，`Mul_Node` 更新自己的 `value`、`value_version` 和 `parents_values_versions`，然后将**新计算出的值和新版本号**返回给 `Add_Node`。

5.  **`Add_Node` 的决策与计算**:
    - `Add_Node` 此时收齐了 `b` 和 `Mul_Node` 的响应。
    - 它进行本地检查，发现 `b` 的版本号匹配，但 `Mul_Node` 的版本号**不匹配**。
    - `Add_Node` 判定自己也是“脏的”，必须重新计算。
    - 它使用从 `b`（缓存）和 `Mul_Node`（新值）获取的值，执行加法运算，得到最终结果 `y`。

这个例子清晰地展示了“检查并返回节点值”的流程如何精准地将计算限制在从 `x` 开始的、受影响的路径上，而 `b` 和 `w` 的昂贵计算（如果是复杂节点）则被完全跳过。

### 3.2. 反向传播：基于拓扑排序的梯度累加

反向传播的实现将从递归方式转变为基于拓扑排序的线性处理，这种变化不仅提高了效率，更重要的是能正确处理梯度累加的特殊性。

#### 3.2.1. 为什么反向传播需要拓扑排序

反向传播与前向传播有本质区别：

- **前向传播**：节点值是父节点值的纯函数计算，可以缓存和复用
- **反向传播**：节点梯度需要**累加**所有子节点的梯度贡献，不是简单替换

在有多路径的图中（如一个节点有多个子节点），递归方式可能导致梯度累加不完整。拓扑排序确保当处理一个节点时，它的所有子节点都已处理完毕，所有梯度贡献都已准备就绪。

#### 3.2.2. 执行流程

1.  **构建拓扑序**:

    - 在启动反向传播之前，`Graph`执行器会对从`result_node`到所有需要计算梯度的`target_node`所构成的子图进行**拓扑排序**。
    - 得到一个线性序列，如`[node1, node2, ..., result_node]`。

2.  **检查前向状态**: 在反向传播一个节点之前，可以利用版本号机制检查其`value`是否为最新。如果不是，可以报错或自动执行一次前向计算。

3.  **执行反向传播**:
    - 将`result_node`的梯度初始化为 1 或单位矩阵。
    - **逆序**遍历拓扑排序列表。对于每个节点：
      - 此时能确保它已从所有下游子节点接收并累加了全部梯度。
      - 利用总梯度，计算对各父节点的梯度贡献。
      - 将梯度贡献传递给父节点进行累加。

#### 3.2.3. 与当前递归实现的对比

当前的递归实现通过深度优先搜索计算梯度，虽然功能正确，但存在以下问题：

- 需要依赖`pass_id`机制避免重复计算
- 执行顺序不可预测，难以调试
- 递归调用栈在复杂图中可能很深

拓扑排序方式则提供了：

- 确定的、可预测的执行顺序
- 每个节点只访问一次，无需`pass_id`检查
- 扁平的控制流，易于调试和优化

### 3.3. Graph 结构体变更

- 移除 `last_forward_pass_id` 和 `last_backward_pass_id` 字段。
- `forward_node` 和 `backward_nodes` 方法的实现将完全重写，以采用拓扑排序和版本控制的逻辑。

## 4. 新架构的优势

- **高效的局部更新**: 当图中只有少量输入变化时，只有受影响的“脏”路径会被重新计算，极大提升了效率。
- **天然支持高级功能**:
  - **部分前向传播**: 只需更新关心的输入，然后请求关心的输出，计算会自动且最小化地在相关子图上发生。
  - **`detach`**: 在构建反向传播的拓扑序时，只需在被`detach`的节点处停止回溯即可，实现非常简单自然。
- **代码解耦与可维护性**: 节点的职责被简化为“如何计算”和“如何求导”。而“何时计算”的复杂调度逻辑被统一移至`Graph`执行器中，使得代码结构更清晰，更易于维护和扩展。

这是一个具有长远价值的架构升级，将为项目未来的发展奠定坚实的基础。

---

## 5. 深入思考与待明确的问题 (2025-07-23)

在分析了当前基于递归和`pass_id`的`backward_node_internal`实现及其测试用例后，针对新的拓扑排序方案，提出以下待讨论和明确的设计细节：

### 5.1. 反向子图的构建策略

新方案的第一步是构建一个从`result_node`到所有`target_nodes`的子图。这个过程的具体算法需要明确。

- **遍历方向**：是从`result_node`开始，沿着反向边（子->父）进行图遍历（如 DFS 或 BFS），直到访问完所有`target_nodes`以及它们到`result_node`路径上的所有节点吗？
- **边界定义**：这个子图的“叶子节点”是`target_nodes`吗？遍历过程中遇到已经访问过的节点应如何处理？

一个清晰的子图构建算法是进行拓扑排序的前提。

### 5.2. 如何处理“部分图”的反向传播

当前的实现通过比较节点的`forward_pass_id`来巧妙地忽略那些未参与前向计算的图分支（参考`test_backward_with_partial_forward_propagation`测试）。

在新方案中，这个逻辑需要被显式地重新设计：

- **方案 A：在子图构建时过滤**：在构建反向子图的遍历过程中，如果遇到一个节点，其`value`是“过时”的（可以通过`value_version`机制判断），则直接跳过该节点，不将其加入子图。
- **方案 B：在拓扑执行时跳过**：先构建一个完整的拓扑序，然后在线性遍历执行时，检查每个节点的`value`是否“过时”，如果过时则跳过其梯度计算。

方案 A 可能更高效，因为它从一开始就减小了图的规模。这需要作为核心设计决策被确定下来。

### 5.3. 梯度累加机制的保留

测试用例`test_continuous_backward_jacobi_accumulation`表明，连续调用`backward_nodes`需要实现梯度累加。

在新方案中，这意味着：

1. 调用`backward_nodes`时不应自动清除之前计算出的梯度。
2. 在线性执行拓扑序，计算某个节点的梯度贡献时，应该是`node.jacobi += contribution`，而不是`node.jacobi = contribution`。

这个行为需要被确认为新方案必须保留的特性。

### 5.4. `detach`功能的具体实现

文档中提到`detach`可以通过在构建子图时“停止回溯”来实现。这需要更具体的定义：

- **标记位置**：`detach`是应该标记在节点上，还是边上？标记在节点上意味着该节点的所有反向路径都被切断。
- **实现方式**：在构建反向子图的遍历算法中，当遇到一个被标记为`detached`的节点时，算法应将其视为一个没有父节点的“叶子节点”，不再继续向上遍历。

明确这些问题将有助于确保从现有实现到新架构的平滑过渡，并完整地保留甚至改进现有功能。

### 5.5. 是否应缓存前向传播的拓扑序以供反向传播复用？

这是一个关于优化的思考：我们是否可以在执行前向传播时，将计算路径的拓扑序缓存下来，以便反向传播时直接复用，从而避免重复的图遍历和排序？

**分析：**

这个想法的初衷是好的，但在实践中可能弊大于利。

- **优点**：

  - **潜在性能提升**：在理想情况下（前向和反向的计算范围完全重合），可以省去一次图的拓扑排序开销。

- **缺点**：
  - **计算范围不匹配**：这是最核心的问题。前向传播（从输入到输出）和反向传播（从损失到参数）的节点范围通常不完全相同。直接复用前向拓扑序，可能导致反向传播包含了不需要的节点（如输入节点），或遗漏了需要的节点。
  - **复杂性剧增**：为了处理范围不匹配的问题，需要引入复杂的逻辑来裁剪或扩展缓存的拓扑序，这会使代码变得难以维护。
  - **内存开销**：为不同的计算路径缓存拓扑序会增加额外的内存消耗。
  - **动态图不友好**：在图结构动态变化的场景下（如 NEAT），维护这些缓存的有效性会成为一个巨大的负担。

**结论：**

**此方案属于过早优化，不建议采用。**

相比之下，**每次反向传播时，根据当前的`result_node`和`target_nodes`动态构建反向子图并进行拓扑排序**，虽然有计算开销，但保证了每次操作的**灵活性和正确性**。这种"即时计算"的策略更简单、更健壮，完全符合当前"先解决有没有，再解决好不好"的原则。

---

## 6. 决策记录

### 2025-12-22: 确认继续搁置，`detach` 等功能可在 `pass_id` 机制下实现

**背景**：复核了当前 `pass_id` 机制与提案中 `value_version` 机制的关系，特别是关于 `detach`、`retain_graph`、`no_grad` 等高级梯度控制功能的实现可行性。

**结论**：

1. **当前 `pass_id` 机制功能完备**：已有充分的测试覆盖（如 `test_forward_with_partial_forward_propagation`），"避免重复计算"功能正常工作。

2. **高级梯度控制功能无需重构即可实现**：

   - `detach`：在 `backward_node_internal` 中添加 `is_detached` flag 检查即可
   - `retain_graph`：在 `backward_nodes` 完成后控制是否释放中间值
   - `no_grad`：扩展现有 `eval_mode` 机制

3. **两种机制功能等价**：`value_version` 在代码组织上可能更"优雅"，但不是功能必需。`pass_id` + 递归方式可以实现完全相同的语义。

4. **重构时机**：当出现以下条件时重新评估：
   - 图规模超过数千节点，遍历开销成为瓶颈
   - NEAT 动态演化导致频繁局部更新
   - 需要更复杂的部分前向传播模式

**相关文档**：

- 新建 [梯度流控制设计](.doc/design/gradient_flow_control_design.md) 文档，详细描述 `no_grad`、`detach`、`retain_graph` 的 API 设计和实现方案
